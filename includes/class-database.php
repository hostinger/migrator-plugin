<?php
/**
 * The class responsible for database operations.
 *
 * @package CustomMigrator
 */

/**
 * Database class.
 */
class Custom_Migrator_Database {

    /**
     * The filesystem handler.
     *
     * @var Custom_Migrator_Filesystem
     */
    private $filesystem;

    /**
     * Initialize the class.
     */
    public function __construct() {
        $this->filesystem = new Custom_Migrator_Filesystem();
    }

    /**
     * Export the database to a SQL file.
     *
     * @param string $sql_file The path to the SQL file.
     * @throws Exception If the database export fails.
     */
    public function export($sql_file) {
        global $wpdb;

        // Check if we should try to compress
        $use_compression = function_exists('gzopen');
        
        // If compression is enabled, ensure .gz extension
        if ($use_compression && substr($sql_file, -3) !== '.gz') {
            $sql_file .= '.gz';
        } elseif (!$use_compression && substr($sql_file, -3) === '.gz') {
            // Remove .gz extension if compression is not available
            $sql_file = substr($sql_file, 0, -3);
        }
        
        // For compressed output, we'll write to a temp file first
        $temp_sql_file = null;
        $output_fp = null;
        
        if ($use_compression) {
            $temp_sql_file = tempnam(sys_get_temp_dir(), 'sql_export_');
            if (!$temp_sql_file) {
                throw new Exception('Cannot create temporary SQL file');
            }
            $output_fp = @fopen($temp_sql_file, 'wb');
        } else {
            // Direct output to the final file if no compression
            $output_fp = @fopen($sql_file, 'wb');
        }
        
        if (!$output_fp) {
            if ($temp_sql_file) {
                @unlink($temp_sql_file);
            }
            throw new Exception('Cannot create SQL file for writing');
        }
        
        // Create a connection using mysqli
        $mysqli = new mysqli(DB_HOST, DB_USER, DB_PASSWORD, DB_NAME);
        
        if ($mysqli->connect_error) {
            fclose($output_fp);
            if ($temp_sql_file) {
                @unlink($temp_sql_file);
            }
            throw new Exception('Database connection failed: ' . $mysqli->connect_error);
        }

        // CRITICAL: Set character encoding to prevent question marks during export
        $mysqli->set_charset('utf8mb4');
        
        // Verify encoding was set correctly
        $charset_result = $mysqli->query("SELECT @@character_set_connection");
        if ($charset_result) {
            $charset_row = $charset_result->fetch_array();
            $current_charset = $charset_row[0];
            $charset_result->free();
            $this->filesystem->log("Database connection charset: {$current_charset}");
            
            // Warn if charset is not UTF-8
            if (!in_array($current_charset, ['utf8', 'utf8mb4'])) {
                $this->filesystem->log("WARNING: Non-UTF8 charset detected. This may cause encoding issues.");
            }
        }

        // Set timeout settings to prevent hanging
        $mysqli->query("SET SESSION wait_timeout = 300");
        $mysqli->query("SET SESSION interactive_timeout = 300");
        $mysqli->query("SET SESSION sql_mode = ''");
        
        // ENHANCED: Set additional encoding parameters for consistent export
        $mysqli->query("SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci");
        $mysqli->query("SET CHARACTER_SET_CLIENT = utf8mb4");
        $mysqli->query("SET CHARACTER_SET_RESULTS = utf8mb4");
        $mysqli->query("SET CHARACTER_SET_CONNECTION = utf8mb4");

        // Write SQL header information
        $header = "-- WordPress Database Export\n" .
                  "-- Generated by Custom Migrator\n" .
                  "-- Date: " . gmdate( 'Y-m-d H:i:s' ) . " GMT\n" .
                  "-- Host: " . DB_HOST . "\n" .
                  "-- Database: " . DB_NAME . "\n" .
                  "-- Export Charset: utf8mb4\n" .
                  "-- WordPress Charset: " . get_option('blog_charset', 'UTF-8') . "\n\n" .
                  "/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n" .
                  "/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n" .
                  "/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n" .
                  "/*!40101 SET NAMES utf8mb4 */;\n" .
                  "/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;\n" .
                  "/*!40103 SET TIME_ZONE='+00:00' */;\n" .
                  "/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;\n" .
                  "/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;\n" .
                  "/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;\n" .
                  "/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\n\n";
                  
        fwrite($output_fp, $header);

        // Get all tables
        $tables = [];
        $result = $mysqli->query("SHOW TABLES");
        while ($row = $result->fetch_array()) {
            $tables[] = $row[0];
        }
        $result->free();

        // Track progress
        $total_tables = count($tables);
        $this->filesystem->log("Exporting $total_tables tables...");
        $table_count = 0;

        // Loop through tables
        foreach ($tables as $table) {
            $table_count++;
            
            // Log progress every 5 tables
            if ($table_count % 5 === 0 || $table_count === $total_tables) {
                $this->filesystem->log("Exported $table_count of $total_tables tables");
            }
            
            // Get CREATE TABLE statement
            $result = $mysqli->query("SHOW CREATE TABLE `$table`");
            if ($result) {
                $row = $result->fetch_array();
                $create_table = $row[1];
                $result->free();
                
                // Write table structure
                fwrite($output_fp, "\n\n-- Table structure for table `$table`\n");
                fwrite($output_fp, "DROP TABLE IF EXISTS `$table`;\n");
                fwrite($output_fp, "$create_table;\n\n");
                
                // Get table data with timeout handling
                $this->export_table_data($mysqli, $output_fp, $table);
            }
        }

        // Write SQL footer
        $footer = "\n/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;\n" .
                  "/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;\n" .
                  "/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;\n" .
                  "/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;\n" .
                  "/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;\n" .
                  "/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n" .
                  "/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n" .
                  "/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n";
                  
        fwrite($output_fp, $footer);
        
        // Close file and database connection
        fclose($output_fp);
        $mysqli->close();
        
        // Compress the file if needed
        if ($use_compression && $temp_sql_file) {
            $this->filesystem->log("Compressing SQL file...");
            $gz_success = $this->compress_file($temp_sql_file, $sql_file);
            
            if (!$gz_success) {
                // Fall back to uncompressed file if compression failed
                $this->filesystem->log("Compression failed, using uncompressed SQL file");
                $uncompressed_file = substr($sql_file, 0, -3);
                if (rename($temp_sql_file, $uncompressed_file)) {
                    $sql_file = $uncompressed_file;
                } else {
                    @unlink($temp_sql_file);
                    throw new Exception('Failed to create SQL file');
                }
            } else {
                // Remove the temporary file if compression was successful
                @unlink($temp_sql_file);
            }
        }
        
        $this->filesystem->log("Database export completed successfully to $sql_file");
        
        // Update the stored filenames option to reflect any changes in extension
        $filenames = get_option('custom_migrator_filenames');
        if ($filenames && isset($filenames['sql'])) {
            $filenames['sql'] = basename($sql_file);
            update_option('custom_migrator_filenames', $filenames);
        }
        
        return $sql_file; // Return the actual file path used
    }

    /**
     * Compress a file using gzip.
     *
     * @param string $source Source file path.
     * @param string $destination Destination file path.
     * @return bool True on success, false on failure.
     */
    private function compress_file($source, $destination) {
        if (!function_exists('gzopen')) {
            return false;
        }
        
        $source_handle = @fopen($source, 'rb');
        if (!$source_handle) {
            return false;
        }
        
        $dest_handle = @gzopen($destination, 'wb9'); // Maximum compression
        if (!$dest_handle) {
            fclose($source_handle);
            return false;
        }
        
        // Read source file in smaller chunks to avoid memory issues
        $success = true;
        $chunk_size = 1024 * 1024; // 1MB chunks
        
        try {
            while (!feof($source_handle)) {
                $buffer = fread($source_handle, $chunk_size);
                if ($buffer === false) {
                    $success = false;
                    break;
                }
                
                $bytes_written = gzwrite($dest_handle, $buffer);
                if ($bytes_written === false || $bytes_written != strlen($buffer)) {
                    $success = false;
                    break;
                }
            }
        } catch (Exception $e) {
            $success = false;
        }
        
        // Close file handles
        fclose($source_handle);
        gzclose($dest_handle);
        
        // Verify the compressed file exists and has content
        if ($success && (!file_exists($destination) || filesize($destination) < 50)) {
            $success = false;
        }
        
        return $success;
    }

    /**
     * Export table data with individual INSERT statements (like All-in-One WP Migration).
     *
     * @param mysqli   $mysqli  MySQL connection.
     * @param resource $sql_fp  File pointer for the SQL file.
     * @param string   $table   Table name.
     */
    private function export_table_data($mysqli, $sql_fp, $table) {
        $start_time = time();
        $max_execution_time = 30; // Maximum 30 seconds per table
        
        try {
            // Get row count with timeout check
            $count_result = $mysqli->query("SELECT COUNT(*) FROM `$table`");
            if (!$count_result) {
                $this->filesystem->log("Error getting row count for table `$table`: " . $mysqli->error);
                return;
            }
            
            $count_row = $count_result->fetch_array();
            $total_rows = $count_row[0];
            $count_result->free();
            
            if ($total_rows === 0) {
                return;
            }
            
            $this->filesystem->log("Exporting table `$table` with $total_rows rows");
            
            // Get column information
            $columns_result = $mysqli->query("SHOW COLUMNS FROM `$table`");
            if (!$columns_result) {
                $this->filesystem->log("Error getting columns for table `$table`: " . $mysqli->error);
                return;
            }
            
            $columns = [];
            while ($column = $columns_result->fetch_assoc()) {
                $columns[] = $column;
            }
            $columns_result->free();
            
            // Get primary keys for optimized queries (like All-in-One WP Migration)
            $primary_keys = [];
            $keys_result = $mysqli->query("SHOW KEYS FROM `$table` WHERE Key_name = 'PRIMARY'");
            if ($keys_result) {
                while ($key = $keys_result->fetch_assoc()) {
                    $primary_keys[] = $key['Column_name'];
                }
                $keys_result->free();
            }
            
            // Use batch processing but write individual INSERT statements (All-in-One WP Migration style)
            $batch_size = 500;
            $offset = 0;
            $exported_rows = 0;
            $transaction_size = 100; // Start transaction every 100 INSERT statements
            
            while ($offset < $total_rows) {
                // Check timeout
                if ((time() - $start_time) > $max_execution_time) {
                    $this->filesystem->log("Timeout reached for table `$table` after exporting $exported_rows/$total_rows rows");
                    break;
                }
                
                // Build optimized query like All-in-One WP Migration
                if (!empty($primary_keys)) {
                    $table_keys = implode(', ', array_map(function($key) { return "`$key`"; }, $primary_keys));
                    // Use JOIN optimization for better performance
                    $query = sprintf(
                        'SELECT t1.* FROM `%s` AS t1 JOIN (SELECT %s FROM `%s` ORDER BY %s LIMIT %d, %d) AS t2 USING (%s)',
                        $table, $table_keys, $table, $table_keys, $offset, $batch_size, $table_keys
                    );
                } else {
                    // Fallback for tables without primary keys
                    $query = "SELECT * FROM `$table` LIMIT $offset, $batch_size";
                }
                
                $result = $mysqli->query($query);
                
                if (!$result) {
                    $this->filesystem->log("Error querying table `$table` at offset $offset: " . $mysqli->error);
                    break;
                }
                
                $batch_rows = 0;
                
                while ($row = $result->fetch_assoc()) {
                    // Check timeout during row processing
                    if ((time() - $start_time) > $max_execution_time) {
                        $this->filesystem->log("Timeout during row processing for table `$table`");
                        // End current transaction if active
                        if ($exported_rows % $transaction_size !== 0) {
                            fwrite($sql_fp, "COMMIT;\n");
                        }
                        $result->free();
                        return;
                    }
                    
                    // Start transaction (like All-in-One WP Migration)
                    if ($exported_rows % $transaction_size === 0) {
                        fwrite($sql_fp, "START TRANSACTION;\n");
                    }
                    
                    $values = [];
                    
                    foreach ($columns as $column) {
                        $column_name = $column['Field'];
                        $column_type = $column['Type'];
                        $value = $row[$column_name];
                        
                        if (is_null($value)) {
                            $values[] = "NULL";
                        } elseif (strpos($column_type, 'int') === 0 || 
                                strpos($column_type, 'float') === 0 || 
                                strpos($column_type, 'double') === 0 || 
                                strpos($column_type, 'decimal') === 0) {
                            $values[] = $value;
                        } else {
                            // Handle text fields with better escaping
                            $escaped_value = $mysqli->real_escape_string($value);
                            $values[] = "'" . $escaped_value . "'";
                        }
                    }
                    
                    // Write individual INSERT statement (All-in-One WP Migration style)
                    // This NEVER has semicolon issues because each statement is complete
                    $table_values = implode(',', $values);
                    $insert_statement = "INSERT INTO `$table` VALUES ({$table_values});\n";
                    fwrite($sql_fp, $insert_statement);
                    
                    $batch_rows++;
                    $exported_rows++;
                    
                    // End transaction (like All-in-One WP Migration)
                    if ($exported_rows % $transaction_size === 0) {
                        fwrite($sql_fp, "COMMIT;\n");
                    }
                }
                
                $result->free();
                $offset += $batch_size;
                
                // Progress reporting for large tables
                if ($total_rows > 1000 && ($offset % ($batch_size * 4)) === 0) {
                    $percent = round(($exported_rows / $total_rows) * 100, 1);
                    $this->filesystem->log("Table `$table`: $exported_rows/$total_rows rows ($percent%)");
                }
                
                // Small pause to prevent overwhelming the database
                if ($batch_rows > 0) {
                    usleep(10000); // 0.01 second pause
                }
            }
            
            // End final transaction if needed
            if ($exported_rows % $transaction_size !== 0) {
                fwrite($sql_fp, "COMMIT;\n");
            }
            
            $table_time = time() - $start_time;
            $this->filesystem->log("Completed table `$table`: $exported_rows/$total_rows rows in {$table_time}s");
            
        } catch (Exception $e) {
            $this->filesystem->log("Exception while exporting table `$table`: " . $e->getMessage());
        }
    }
}